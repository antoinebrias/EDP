%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Current  value function
% (we look for the control optimizing this function)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



function [ res, resUnweighted ] = fun_optim_td(support_states,control,value_function,model,mdlstruct,optstruct,dpstruct)


,gamma

paramReward
dpstruct.


mdlstruct,optstruct,dpstruct



discount_factor = optstruct.discount_factor;
reward = optstruct.reward;


dpstruct.



SS= repelem(support_states,size(control,1),1);
currentU=repmat(control,size(support_states,1),1);
currentX = SS;

[mu,~]=model(currentX,currentU),1); % posterior mean
nextX = mu;%.*currentU;%.*currentU./(currentU+eps);

nextX(nextX<0)=0;

if isempty(MdlV)
    %  [res,resI]=R(currentX,histU(:,1));
    [res,resUnweighted]=R(currentX*0,currentU*0,paramReward);
    %      [res,resI]=R(nextX,muGPu.*fracU,paramReward);
    %     res=res.*0;
    %     resI=resI.*0;
else
    %[res,resI]=R(currentX,histU(:,1));
    
    [resTotTmp,resUnweighted]=R(currentX,currentU,paramReward);
    %     [res,resI]=R(nextX,muGPu.*fracU,paramReward);
    %     [resV,~,resVI]=evalValueFunction( MdlV,[nextX currentX(:,~isempty(histX)) histX(:,1:end-1) currentU(:,~isempty(histU))  histU(:,1:end-1) ],paramReward );
    
    [muV,vV]=postMdl(MdlV,nextX,[],1 );
    
    
    
    resV = muV*paramReward'; resVI = muV;
    
    res = resTotTmp+gamma*resV;
    resUnweighted = resUnweighted+gamma*resVI;
    
    
end
%Since we solve the min pb we need the opposite values
res = -res;
resUnweighted = -resUnweighted;
end