%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Support states list generation
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


function [dpstruct] = generate_support_states(mdlstruct,dpstruct)


if ~isfield(dpstruct,'n_support_states')
% number of support states
dpstruct.n_support_states=50;
end

switch generating_support_states_method
    case 'grid'
        
    case 'random'
        maxdata = repmat(max(),1,n_lags_max)repelem(a,1,2)
        mindata = 
       dpstruct.support_states = rand(dpstruct.n_support_states,mdlstruct.n_lags_max.*mdlstruct.n_dim ).*(max()-min())-min();
end
% How to generate the support states used here
% 'random' -> randomely generated 
% 'grid'   -> create a grid of support states (number of points on each dimension equal to dpstruct.nb_support_states^(1/n) (round to lower))
dpstruct.generating_support_states_method = 'random';
dpstruct = generate_support_states(mdlstruct,dpstruct);

end
